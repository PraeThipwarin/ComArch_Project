        lw      0       1       n       # $1 = n
        lw      0       2       r       # $2 = r
        lw      0       5       stack   # $5 = stack pointer
        jalr    6       7               # call comb; assume comb address in $6
        halt

comb:   sw      5       7       stack   # save return address
        add     5       6       5       # SP++

        sw      5       1       stack   # save n
        add     5       6       5       # SP++

        sw      5       2       stack   # save r
        add     5       6       5       # SP++

        beq     2       0       comb_return_one  # if r==0
        beq     1       2       comb_return_one  # if n==r

        add     1       reg_neg1   1    # n = n - 1
        jalr    6       7              # comb(n-1, r)
        sw      5       3       stack   # save result1
        add     5       6       5

        add     5       reg_neg1   5     # SP--
        lw      5       1       stack    # restore n
        add     1       reg_neg1   1     # n = n - 1
        add     2       reg_neg1   2     # r = r - 1
        jalr    6       7               # comb(n-1, r-1)

        add     5       reg_neg1   5
        lw      5       4       stack   # load result1
        add     3       4       3        # $3 = result1 + result2

        beq     0       0       comb_epilogue

comb_return_one:
        add     0       6       3        # $3 = 1

comb_epilogue:
        add     5       reg_neg1   5
        lw      5       2       stack

        add     5       reg_neg1   5
        lw      5       1       stack

        add     5       reg_neg1   5
        lw      5       7       stack

        jalr    7       0               # return

n:      .fill   7
r:      .fill   3
reg_neg1:.fill  -1
stack:  .fill   0
combAdr:.fill   comb
